#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const node_1 = require("vscode-languageserver/node");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const settings_1 = tslib_1.__importDefault(require("./settings"));
const constants_1 = require("./constants");
const commands_1 = require("./commands");
const buffered_message_queue_1 = tslib_1.__importDefault(require("./buffered-message-queue"));
const validate_1 = require("./validate");
const connection = (0, node_1.createConnection)();
const documents = new node_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
documents.listen(connection);
const settings = new settings_1.default(connection);
const messageQueue = new buffered_message_queue_1.default(connection);
(0, validate_1.registerValidateHandlers)(connection, messageQueue, documents, settings);
(0, commands_1.registerCommandHandlers)(connection, messageQueue, documents, settings);
let clientCapabilities = {};
connection.onInitialize((param) => {
    clientCapabilities = param.capabilities;
    settings.initialize(clientCapabilities);
    return {
        capabilities: {
            codeActionProvider: true,
            documentFormattingProvider: true,
            executeCommandProvider: {
                commands: [
                    constants_1.CommandIds.applyAutoFixes,
                    constants_1.DisableRuleCommandIds.applyDisableRuleInline,
                    constants_1.DisableRuleCommandIds.applyDisableRuleToFile,
                    constants_1.DisableRuleCommandIds.applyDisableRuleToLine,
                    constants_1.DisableRuleCommandIds.applyDisableRuleToRange,
                ],
            },
            textDocumentSync: {
                openClose: true,
                change: node_1.TextDocumentSyncKind.Full,
                willSaveWaitUntil: true,
                save: {
                    includeText: false,
                },
            },
        },
    };
});
connection.onInitialized(() => {
    if (clientCapabilities.workspace &&
        clientCapabilities.workspace.didChangeConfiguration &&
        clientCapabilities.workspace.didChangeConfiguration.dynamicRegistration) {
        connection.client.register(node_1.DidChangeConfigurationNotification.type, undefined);
    }
});
connection.onDidChangeConfiguration((params) => {
    settings.clientConfigurationChanged(params);
    (0, validate_1.validateAll)(messageQueue, documents.all());
});
documents.onDidClose((event) => {
    settings.closeDocument(event.document);
});
process.on("uncaughtException", (error) => {
    let message = error.message;
    if (error.stack) {
        message = `${message}\n\n${error.stack}`;
    }
    connection.console.error(`Uncaught exception: ${message}`);
});
connection.console.info(`stylelint running in node ${process.version}`);
connection.listen();
